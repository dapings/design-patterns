# 建造者模式

建造者模式(Builder Pattern)又称构建者模式或生成器模式。

建造者模式允许你创建不同类型的复杂对象，而无需知道其具体的构造过程。通过将对象的构建过程与其表示分离，允许通过相同的构建过程创建不同的表示。其中，具体建造过程由具体建造者(BuilderX)负责，而指挥者(Director)负责控制具体建造者的构建过程。 

通过设置不同的具体建造者，我们可以创建不同类型的对象。我们可以将对象的构建过程分解成多个独立的步骤，并且可以在不同的步骤中使用不同的算法或方法来创建对象。

原理与代码掌握起来并不难，其难点在于应用场景。

## 包含的几个角色

1. 要创建的复杂对象。
2. 抽象建造者（Builder）：定义构建产品所需的接口和方法。
3. 具体建造者（Concrete Builder）：实现抽象建造者接口和方法，定义对象的具体构建过程。
4. 指挥者（Director）：控制具体建造者的构建过程，负责调用具体建造者的方法来构建对象。

## 优点

1. 可以创建不同类型的复杂对象，而无需知道其具体的构造过程。
2. 可以将对象的构建过程分解成多个独立的步骤，使得构建过程更加灵活和可控。
3. 可以在不同的步骤中使用不同的算法或方法来创建对象，提高了代码的复用性和可维护性。
4. 可以避免创建不完整或不正确的对象，提高了代码的健壮性和可靠性。

## 缺点

1. 需要定义多个类型和接口，增加了代码的复杂性和理解难度。
2. 构建过程可能会变得复杂，需要仔细设计和实现。

## 直接使用构造函数或配合 setter 方法就能创建对象，为什么还需要通过建造者模式创建了？

在某些情况下，当对象的构建过程较为复杂或包含多个可选参数时，直接使用构造函数或setter方法可能会导致以下问题：

1. 参数过多：如果一个类型有很多属性或参数，使用构造函数或setter方法可能需要传递大量的参数，使得代码难以理解和维护。
2. 参数顺序问题：使用构造函数时，参数的顺序非常重要。如果参数顺序错误，可能会导致创建出的对象属性值不正确。而且，如果有多个可选参数，每次调用构造函数时都需要记住参数的顺序，容易出错。
3. 对象可变性：使用setter方法可以在对象创建后修改其属性值，这可能导致对象在不完全构建的情况下被使用，或者在创建后被意外地修改。

建造者模式通过将对象的构建过程封装在一个独立的建造者对象中，可以解决上述问题。

## 建造者模式和工厂模式都可以创建对象，它们的区别是什么？

它们在对象创建的方式和使用场景上有一些区别：

1. 创建方式：
    - 工厂模式使用一个工厂类来封装对象的创建过程，通过调用工厂类的方法来创建对象。工厂类可以根据不同的条件或参数来创建不同类型的对象。
    - 建造者模式将对象的构建过程分解成多个独立的步骤，并由一个指挥者类来控制具体建造者的构建过程。建造者模式通过链式调用或方法调用的方式来设置对象的属性，最终构建出复杂对象。

2. 使用场景：
    - 工厂模式适用于创建不同类型的对象，并且客户端只需要知道工厂类和产品接口即可。工厂模式隐藏了对象的创建细节，使得客户端与具体产品的实现解耦。
    - 建造者模式适用于创建复杂对象，特别是当对象的构建过程涉及多个步骤或可选参数时。建造者模式通过将对象的构建过程分解成多个步骤，并提供一种流畅的方式来设置对象的属性。

3. 灵活性：
    - 工厂模式相对较简单，适用于创建对象的场景较为固定，不需要灵活地调整对象的构建过程。
    - 建造者模式更加灵活，允许在构建过程中根据需要调整对象的属性设置，以创建不同的表示。 

工厂模式适用于创建不同类型的对象，而建造者模式适用于创建复杂对象，并且需要灵活地控制对象的构建过程。